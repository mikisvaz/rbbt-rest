- new_info = {}
- info.each{|k,v| new_info[k] = v unless k.to_s == 'dependencies' || k.to_s == 'exception' || k.to_s == 'backtrace'}
- exception = info[:exception]

- status = info[:status]
.job_info.clean_list.ui.segment
  .ui.header 
    Info:
    %span.status(class=status)= job.name

  = hash2dl(new_info)

.ui.segment.job_inputs
  .ui.header
    %h3 Inputs (recursive)
  .ui.content
    %dl
      - inputs = job.recursive_inputs
      - inputs.zip(inputs.fields).each do |i,f|
        %dt= f
        %dd
          - case i
          - when Array
            %ul
              - i.each do |e|
                - if String === e
                  %li= e
                - else
                  %li= e.inspect
          - when String
            %pre= i
          - else
            %pre
              = i.inspect

- if exception
  - backtrace = exception[:backtrace]
  .error_backtrace.clean_list.ui.segment
    .ui.header Backtrace
    %pre.ui.content
      - require 'rbbt/util/colorize'
      - pallete = {}
      - matches = %w(views workflows rbbt).collect{|w| /\/#{w}/ }
      - colors = Colorize.distinct(matches)
      %ul
        - backtrace.each do |line|
          - color = nil
          - matches.each_with_index do |m,i|
            - if m.match(line)
              - color = colors[i].darken(0.3).to_s 
              - break

          - style = color ? ';color:'+color : ""
          %li(style="font-size:0.9em;font-family:monospace#{style}")= line.sub('`',"'")

- if info[:dependencies] and info[:dependencies].any?
  .ui.segment
    .ui.header
      %h3 Dependencies
    .ui.content
      = partial_render('partials/dependencies', :job => job)
